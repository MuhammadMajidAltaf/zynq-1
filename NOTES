Need to load PMBUS modules manually under Linux. Excerpt from Documentation/hwmon/pmbus:

-------------------------------------------------------------
This driver does not probe for PMBus devices, since there is no register
which can be safely used to identify the chip (The MFG_ID register is not
supported by all chips), and since there is no well defined address range for
PMBus devices. You will have to instantiate the devices explicitly.

Example: the following will load the driver for an LTC2978 at address 0x60
on I2C bus #1:
$ modprobe pmbus
$ echo ltc2978 0x60 > /sys/bus/i2c/devices/i2c-1/new_device

In our particular case
$ echo ucd9200 52 > /sys/bus/i2c/devices/i2c-8/new_device

Sometimes the multiplexer seems to crash, deleting and re-adding the devices seems to
-------------------------------------------------------------

There are three PMBUS controllers on the I2C at addresses 52, 53, 54 in I2C8 (under I2C0 multiplexer as port 7)

Controller1 (52):
1 VCCINT    1.00V 10A
2 VCCPINT   1.00V 10A
3 VCCAUX    1.80V 10A
4 VCCPAUX   1.80V 10A

Controller2 (53):
1 VCCADJ    2.50V 10A
2 VCC1V5    1.50V 10A -> feeds DDR memory
3 VCCMIO_PS 1.80V 10A
4 VCCBRAM   1.00V 10A

Controller3 (54):
1 VCC3V3    3.30V 10A
2 VCC2V5    2.50V 10A

Uncontrolled:
- VTTDDR_PS 0.75V 3A

Can be found under /sys/class/hwmon/hwmon{0-3}/*
in1 - INPUT RAIL, in2-in5 = OUTPUTS 1-4

V in{1-5}_input
I curr{1-5}_input
P power{1-5}_input
T temp{1-5}_input

-------------------------------------------------------------

Analysing for metrics of choice:
- arithmetic operations are easiest to hardware-ify
- loops/control flow is very difficult
- memory operations - do in the integration logic, or try to setup DMA for the PL (might need to check about PS caches)?

arith:
ADD/AND/LSL/REV/etc. -> easy to map to HDL
MUL/DIV -> edge case complications?
[How to handle flags?]
MOV -> must be handled during the setup phases for the HDL block on PS
[ordering? can parallelize some sets of instructions, etc, but others have dependencies - need to have 'instruction clock' for the PL!]

-------------------------------------------------------------

add r1, r2
add r3, r4   <- parallel

add r1, r2
add r3, r1  <- need ordering

add r1, r2
mov r3, r4  <- independent
mov r4, r1  <- needs r1 from (1)

-------------------------------------------------------------

want to logic-ize simple loops
loops might be in 1 of 2 forms:
- unrolled -> should be caught by being a basic-block!?
- rolled -> need to generate a CFG?

likely to have been vectorized by the compiler?

vector example:
void add_ints(int * __restrict pa, int * __restrict pb, unsigned int n, int x)
{
      unsigned int i;
      
          for(i = 0; i < (n & ~3); i++)
                    pa[i] = pb[i] + x;
}

generates things like vadd/vld/vst if vectored - > a good hint for the function being worth consideration beyond BB-offloading

-------------------------------------------------------------

for(int i=0; i<15; i++) {
  for(int j=0; j<15; j++) {
      b[j][i] = a[j][i] ^ 0xffff;
    }
}

unroll this completely into logic? might not fit!

-------------------------------------------------------------

void do_thing(int i) {
  /* arith basic block */
}

for(int i=0; i<15; i++) {
    do_thing(i);
}

-------------------------------------------------------------

* uboot + kernel need to match versions
* device tree needs to match PL (if anything from PL is included in tree), otherwise the kernel will hang during boot.
* PL can be loaded by uboot (manually), or by being included in the generated boot.bin alongside the FSBL.
* Load from userspace by catt'ing into /dev/xdevcfg
